---
title: CSS动画优化思路 
date: 2020-12-08 17:10:20 +0800
tags: [webpack,浏览器]
renderNumberedHeading: true
grammar_cjkRuby: true
---

# **CSS动画优化思路**
### **A: 有一个Animation涉及到以下5个属性，如何对它们的性能进行排序？**  
- background-color
- opacity
- transform
- width
- height


---
#### **要想知道如何进行性能对比，我们首先需要知道浏览器的渲染原理(这里不做详细描述）以及这5个属性对浏览器造成了哪些影响。**

#### 在这之前先了解一个名词：**像素管道**。  
浏览器在首次加载解析到界面完成渲染后，实际上还存在许多可能改变界面的情况，例如用户与界面的交互会产生动画效果或其他按钮的点击反馈等等，这种视觉变化是通过像素管道进行的，以牺牲浏览器的性能为代价，因此如何将这种牺牲降低到最小便是一个值得关注的问题。  

#### 像素管道的5个关键区域
![image](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg)  
- **JavaScript**。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。
- **样式计算**。此过程是根据匹配选择器（例如 .headline 或 .nav > .nav__item）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。
- **布局（重排/回流）**。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 <body> 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。
- **绘制（重绘）**。绘制是填充像素的过程，像素最终合成到用户的屏幕上。它往往是管道中运行时间最长的任务。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。
- **合成**。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。

> 注意：像素管道的执行流程是按照上图来进行的，这也是为什么说重排（回流）一定会导致重绘，而重绘不一定会导致重排的原因。
---

#### 简单来说，像素管道的执行流程一般有三种情况：
**1. JS / CSS > 样式 > 布局 > 绘制 > 合成**  

这种情况因为触发了全部流程，所以性能开销最大。比如修改了元素的left、width、height属性，会触发浏览器重新计算布局，而且是作用在整个文档上，这意味着其他节点的位置大小也要重新进行计算，所以性能耗费最大。  

> 点击[CSS触发器](https://csstriggers.com/)查看会触发布局的CSS属性  

**2. JS / CSS > 样式 > 绘制 > 合成**  

绘制实际上是最消耗性能的，只不过在此种情况下，没有了布局流程，所以触发重绘的动画整体性能开销是比触发重排要小的。触发重绘的一般是非几何属性如：background-color、文本或shadow。实际上除了两个例外的属性（即opacity和transform），更改任何属性都会触发重绘。


**3. JS / CSS > 样式 > 合成**

这种情况性能最优。因为是由合成器单独进行处理，不涉及到重绘和重排。目前会触发此种情况的属性有transform、opacity、filter（滤镜）和will-change，原理是通过新建合成层并将自身提升到此层上，由独立的合成器线程来处理动画，不会影响到其他元素。


#### 例子
**这是使用两种方式实现的相同动画效果：**  
**左侧实现的动画经过的像素管道流程为情况1，右侧实现的动画经过的像素管道流程为情况3**
![image](/assets/images/animation.gif)

##### 现在打开DevTools查看Layer层情况：
这里为了方便查看，我修改成了红色。可以看到右测的动画实际上是新建了一个图层来进行渲染的，也就是常说的CSS硬件加速的原理。这在具有大量DOM节点的网页中可以更明显的体现出优势，避免了重排重绘，因此性能得到提升。
![image](/assets/images/animation1.gif)

但注意有**两个关键因素**会影响像素管道中合成区域的性能：即需要管理的**合成器层数量**，以及**动画的属性**。因此合成层并不是越多越好，除非你的GPU有无限的性能!

### 写到这里其实最初的问题已经有了答案。
### Q：
#### 1.  由于transform和opacity是通过合成层的改变来渲染动画的，因此性能最优；
#### 2.  background-color会触发重绘—>合成，但没有重排，性能次之。
#### 3.  width和height都会引发重排->重绘->合成，性能最差。